# 4장 변수와 스코프, 메모리

책 내용에서 일차적으로 요약. 중요한 개념, 잘 이해안되는 것 찾아보고 공부, 정리하기

> 키워드 
    - 변수의 원시 값과 참조 값
    - 실행 컨텍스트
    - 가비지 컬렉션

- 변수 특징
  - 느슨한 타입을 취함
  - 데이터 타입의 규칙 없음.
  - 값과 타입이 실행 중 변경 가능.

### 4.1 원시 값과 참조 값
- **원시 값**
  - 단순한 데이터
  - Undefined, Null, 불리언, 숫자, 문자열
  - "값으로" 접근한다. 실제 값을 조작 가능.
- **참조 값**
  - 여러 값으로 구성되는 객체
  - 메모리에 저장된 객체.
  - 자바스크립트는 메모리 위치에 직접 접근 허용 안함.
  - 객체의 메모리 공간을 직접 조작 불가능
  - 객체를 조작할 때 객체 자체가 아니라 해당 객체에 대한 참조를 조작하는 것임. => 객체를 가리키는 값은 참조로 접근한다.
- 동적 프로퍼티
  - 참조 값을 다룰 때는 프로퍼티와 메서드 추가 혹은 변경, 삭제 가능.
    ```js
    var person = new Object();
    person.name = "Nicholas";
    console.log(person.name);    //"Nicholas"
    ```
    - 객체 생성 후 person 변수에 저장
    - name 프로퍼티 추가
    - 문자열 할당
  - 참조 값은 동적으로 프로퍼티를 추가할 수 있다.
- 4.1.2  값 복사
  - 원시 값과 참조 값은 변수에서 다른 변수로 값을 복사할 때 다르게 동작한다.
  - 원시 값
    - 현재 저장된 값을 새로 생성 후 변수에 복사
  - 참조 값
    - 참조 값을 다른 변수로 복사 시, 원래 변수에 들어있던 값이 복사됨. 
    - 객체가 아니라 **힙**에 저장된 객체를 가리키는 포인터이다.
    - 복사 시 두 변수는 같은 객체를 가리킴.
    > 힙 : 메모리 영역 중 하나. 브라우저가 쓰는 메모리.
- 4.1.3 매개변수 전달
  - 함수 매개변수는 모두 값으로 전달된다.
  - 매개변수를 값 형태로 넘기면 해당 값은 지역변수에 복사됨.
  - arguments 객체의 한 자리를 차지.
  - 참조 형태로 넘기면 메모리 상 값의 위치가 지역변수에 저장되므로, 변경 시 함수 바깥에도 해당 내용이 변경됨.

```js
function addTen(num) {
    num += 10;
    return num;
}

var count = 20
var result = addTen(count);
console.log(count);    //20
console.log(result);   //10
```
 - 매개변수로 넘겨받은 num 은 지역변수. 
 - 변수 count가 복사되어 매개변수로 전달된다.

```js
function setName(obj) {
    obj.name = "Nicholas";
}

var person = new Object();
setName(person);
console.log(person.name);    //"Nicholas"
```
- setName함수에 객체가 담긴 person을 넘기면 객체를 obj 매개변수에 복사. (참조값)
- 결과적으로 함수 내부의 obj와 person이 같은 객체를 가리킴.
- 함수 내부에서 obj에 name 프로퍼티 추가 시 함수 외부 person객체에도 반영됨.
- obj가 가리키는 것이 힙에 존재하는 전역 객체이기 때문. 

```js
function setName(obj) {
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
}

var person = new Object();
setName(person);
console.log(person.name);    //"Nicholas"
```

4.1.4 타입 판별
- `typeof `연산자는 변수가 원시 타입인지 파악하는데 최적임. (참조 타입은 아니다.)
- 값이 객체 이거나 null이면 "object" 반환.

- 참조 타입일 경우 어떤 타입의 객체인지
  - `instanceof` 연산자 사용.
  - 변수가 주어진 참조 타입의 인스턴스일 때 true 반환.
  - 모든 참조 값은 Object의 인스턴스로 정의되어 있음.
```js
console.log(person instanceof Object);
```
  > 내부에 [\[Call]] 메서드를 가진 객체. => typeof 결과 : "function".. ??
### 4.2 실행 컨텍스트와 스코프
- **실행 컨텍스트** (execution context, EC). 
  - 변수나 함수의 실행 컨텍스트는 다른 데이터에 접근 가능한지, 어떻게 행동하는 지 규정.
  - 변수 객체 (variable object, VO) 
    - 정의된 모든 변수, 함수
  - 전역 컨텍스트
    - 가장 바깥쪽에 존재하는 실행 컨텍스트.
    - 웹 브라우저에서는 window.
    - 실행 컨텍스트는 코드가 모두 실행되면 파괴됨.
      - 컨텍스트 내부 정의 변수, 함수도 파괴.
    - 전역 컨텍스트는 애플리케이션이 종료될 때. , 웹 페이지를 나갈때, 브라우저를 닫을 때 종료.
  - 함수 호출 시 독자적인 실행 컨텍스트 생성.
  - 함수 컨텍스트가 컨텍스트 스택에 쌓이고, 함수 실행이 끝나면 해당 컨텍스트가 스택에서 제거되고, 이전 컨텍스트를 반환.
- **스코프 체인**(scope chain)
  - 목적 : 실행 컨텍스트가 접근할 수 있는 모든 변수와 함수에 순서를 정의하는 것.
  - 코드가 실행되는 컨텍스트의 변수 객체.
  - 컨텍스트가 함수일 경우 활성화 객체를 변수 객체로 사용한다.
  - "**활성화 객체**" (activation object)
    - arguments 변수 단 하나로 시작한다.
    - 전역 객체에는 존재하지 않음.
    - 스코프체인 순서
      - 해당 컨텍스트를 포함하는 컨텍스트(부모 컨텍스트) - 부모의 부모 컨텍스트, ...  전역 컨텍스트까지 도달.
      - 식별자를 찾을 때 스코프 체인 순서를 따라가며 식별자 검색.
    - 각 컨텍스트는 스코프 체인을 따라 상위 컨텍스트에서 변수,함숨 검색 가능. 반대 방향은 불가능. 

```js

```
- 4.2.1 스코프 체인 확장
  - 실행 컨텍스트에는 전역 컨텍스트와 함수 컨텍스트 두가지만 존재. ( + eval() 호출 시 생성되는 컨텍스트)
  - 스코프체인 확장
    - 임시 변수 객체를 만드는 방법이 있음.
      - try-catch 문의 catch 블록
      - with 문
        - location 객체가 스코프 체인에 추가됨.
      - `TODO`: 예제 이해하기.
- 4.2.2 자바스크립트에는 블록 레벨 스코프가 없다.. 
  - **블록 레벨 스코프** - es6
  - 변수 선언
    - 선언한 변수는 가장 가까운 컨텍스트에 추가됨.
    - var 변수를 선언 없이 초기화 시 전역 컨텍스트에 추가된다.   
  - 식별자 검색
    - 스코프 체인 앞부터 시작하여 검색. 
    - 현재 스코프에 식별자를 찾지 못하면, 스코프 체인을 따라가면서 계속 검색함. 전역 컨텍스트의 변수 객체에 도달할 때 까지 검색이 안되면 정의되지 않은 것으로 판단.
  - 
### 4.3 가비지 콜렉션
- 가비지 콜렉션 언어 : 실행 환경에서 코드 실행 중 메모리를 관리하는 언어
- 필요한 메모리 자동 할당, 및 안쓰는 메모리 자동 회수. 개발자가 메모리 관리 관여 안함.
> 더 이상 사용하지 않을 변수를 찾아내서 해당 변수가 차지하고 있던 메모리를 회수"
 - 주기적으로 실행. 코드 실행 중 특정 시점에 회수하도록 지정도 가능하다.

- 사용하지 않는 변수를 식별하는 기준
  - 표시하고 지우기 (Mark-and-Sweep)
    - 메모리에 저장된 변수 전체에 표시를 남김. 
    - 컨텍스트에 있는 변수, 컨텍스트에 있는 변수가 참조하는 변수에서 표시를 지움
    - 표시가 남아있는 변수 -> 삭제
  - 참조 카운팅 (Reference Counting)
    - 값이 얼마나 많이 참조되었는지 추적하는 방식.
    - 변수 선언 후 참조 값이 할당되면 카운트 : +1
    - 다른 변수가 같은 값 참조 시 카운트 증가.
    - 해당 값을 참조하는 변수에 다른 값을 할당 시 카운트 감소
    - 값의 참조가 0이 되면 메모리 회수.
    - 문제
      - 순환 참조 시 참조 카운트가 0이 될 수 없음.
 4.3.3 성능
  - 가비지 컬렉터는 주기적으로 실행됨.
  - 비용이 드는 작업이므로 타이밍이 중요하다.
  - IE 는 임계점을 두고 해당 값 초과 시 가비지 컬렉터 실행.
    - 변수를 많이 사용하는 경우 gc 자주 실행하는 문제.
    - IE7
      - 임계점을 동적으로 변경하여 성능 개선. 
 4.3.4 메모리관리
  - 개발자가 메모리 관리를 신경쓰지 않아도 된다.
  - 브라우저 상 메모리는 일반 데스킄톱 애플리케이션의 메모리보다 현저하게 적다. ( 운영체제 다운 방지)
  - 필요 없어진 데이터에 null을 할당하여 참조를 제거하기. - 전역 변수, 전역 객체의 프로퍼티.
  - 지역 변수는 컨텍스트 빠져나가면 자동으로 참조 제거.
  - 
### 4.4 요약
 - 모든 변수는 스코프라고 부르는 실행 컨텍스트에 존재.
 - 실행 컨텍스트는 변수가 존재하는 기간을 결정. + 어느 코드가 해당 변수에 접근 가능한지 결정
 - **실행 컨텍스트**
   - 전역 컨텍스트
     - 실행컨텍스트 진입 시 마다 스코프 체인이 만들어짐.
     - 스코프체인은 변수와 함수를 검색하는데 쓰임
   - 함수 컨텍스트
     - 해당 스코프에 있는 변수, 해당 스코프를 포함하는 컨텍스트에 있는 변수, 전역 컨텍스트에 있는 변수에 접근 가능
   - 전역 컨텍스트
     - 전역 컨텍스트에 있는 변수와 함수에만 접근 가능.
     - 로컬(함수) 컨텍스트에 있는 데이터에 직접 접근 불가능.
   - 실행 컨텍스트는 변수에 할당된 메모리를 언제 해제할 수 있는 지 판단하는데 도움이 됨.

 - **가비지 컬렉션**
   - 자바스크립트는 자동으로 가비지 컬렉션을 수행한다.
   - 개발자가 메모리 할당, 회수에 신경 쓰지 않아도 됨
   - 가비지 컬렉션 루틴
     > 값이 스코프를 벗어나면 자동 표시, 다음 가비지 컬렉션 실행 시 삭제됨
     - "표시하고 지우기"
       - 현재 사용하지 않는 값에 표시를 남겨 메모리를 회수하는 방법
     - "참조 카운팅"
       - 값이 얼마나 많이 참조 되었는지 추적하는 방법.
       - 거의 쓰이지 않는 방법이며 IE에서는 아직 사용.
       - 순환 참조 문제가 있음.
     - 변수에서 참조 제거 시 순환 참조 문제 해결. 
     - 메모리 효율적으로 관리하기 위해서 전역 객체, 전역 객체의 프로퍼티, 순환 참조에 대한 참조 제거하기.



###### 참고 링크

